<?xml version='1.0'?>
<?xml-stylesheet type='text/xsl' href='pmathml.xsl'?>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>Timing Test of Multi-Threaded Newton Method</title>
<meta name="description" id="description" content="Timing Test of Multi-Threaded Newton Method"/>
<meta name="keywords" id="keywords" content=" multi_newton_time multi_thread Newton Ad speed thread multi_newton newton "/>
<style type='text/css'>
body { color : black }
body { background-color : white }
A:link { color : blue }
A:visited { color : purple }
A:active { color : purple }
</style>
<script type='text/javascript' language='JavaScript' src='_multi_newton_time.cpp_xml.js'>
</script>
</head>
<body>
<table><tr>
<td>
<a href="http://www.coin-or.org/CppAD/" target="_top"><img border="0" src="_image.gif"/></a>
</td>
<td><a href="multi_newton.cpp.xml" target="_top">Prev</a>
</td><td><a href="multi_newton_work.cpp.xml" target="_top">Next</a>
</td><td>
<select onchange='choose_across0(this)'>
<option>Index-&gt;</option>
<option>contents</option>
<option>reference</option>
<option>index</option>
<option>search</option>
<option>external</option>
</select>
</td>
<td>
<select onchange='choose_up0(this)'>
<option>Up-&gt;</option>
<option>CppAD</option>
<option>multi_thread</option>
<option>multi_newton.cpp</option>
<option>multi_newton_time.cpp</option>
</select>
</td>
<td>
<select onchange='choose_down3(this)'>
<option>CppAD-&gt;</option>
<option>Install</option>
<option>Introduction</option>
<option>AD</option>
<option>ADFun</option>
<option>multi_thread</option>
<option>library</option>
<option>cppad_ipopt_nlp</option>
<option>Example</option>
<option>preprocessor</option>
<option>Appendix</option>
</select>
</td>
<td>
<select onchange='choose_down2(this)'>
<option>multi_thread-&gt;</option>
<option>parallel_ad</option>
<option>team_thread.hpp</option>
<option>thread_test.cpp</option>
<option>simple_ad.cpp</option>
<option>harmonic.cpp</option>
<option>multi_newton.cpp</option>
</select>
</td>
<td>
<select onchange='choose_down1(this)'>
<option>multi_newton.cpp-&gt;</option>
<option>multi_newton_time.cpp</option>
<option>multi_newton_work.cpp</option>
</select>
</td>
<td>multi_newton_time.cpp</td>
<td>
<select onchange='choose_current0(this)'>
<option>Headings-&gt;</option>
<option>Syntax</option>
<option>Purpose</option>
<option>ok</option>
<option>time_out</option>
<option>test_time</option>
<option>num_threads</option>
<option>num_zero</option>
<option>num_sub</option>
<option>num_sum</option>
<option>use_ad</option>
<option>Source</option>
</select>
</td>
</tr></table><br/>


.





<center><b><big><big>Timing Test of Multi-Threaded Newton Method</big></big></b></center>
<br/>
<b><big><a name="Syntax" id="Syntax">Syntax</a></big></b>

<br/>

<code><i><font color="black"><span style='white-space: nowrap'>ok</span></font></i><font color="blue"><span style='white-space: nowrap'>&#xA0;=&#xA0;multi_newton_time(</span></font><i><font color="black"><span style='white-space: nowrap'>time_out</span></font></i><font color="blue"><span style='white-space: nowrap'>,&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_threads</span></font></i><font color="blue"><span style='white-space: nowrap'>,&#xA0;<br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_zero</span></font></i><font color="blue"><span style='white-space: nowrap'>,&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_sub</span></font></i><font color="blue"><span style='white-space: nowrap'>,&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_sum</span></font></i><font color="blue"><span style='white-space: nowrap'>,&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>use_ad</span></font></i><font color="blue"><span style='white-space: nowrap'><br/>
)</span></font></code>
 

<br/>
<br/>
<b><big><a name="Purpose" id="Purpose">Purpose</a></big></b>
<br/>
Runs correctness and timing test for a multi-threaded Newton method.
This test uses Newton's method to determine all the zeros of the sine
function on an interval.
CppAD, or hand coded derivatives,
can be used to calculate the derivatives used by Newton's method.
The calculation can be done in parallel on the different sub-intervals.
In addition, the calculation can be done without multi-threading.

<br/>
<br/>
<b><big><a name="ok" id="ok">ok</a></big></b>
<br/>
This return value has prototype

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;bool&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>ok</span></font></i><font color="blue"><span style='white-space: nowrap'><br/>
</span></font></code>
If it is true,
<code><font color="blue">multi_newton_time</font></code> passed the correctness test.
Otherwise it is false.

<br/>
<br/>
<b><big><a name="time_out" id="time_out">time_out</a></big></b>
<br/>
This argument has prototype

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;double&amp;&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>time_out</span></font></i><font color="blue"><span style='white-space: nowrap'><br/>
</span></font></code>
The input value of the argument does not matter.
Upon return it is the number of wall clock seconds required for 
the multi-threaded Newton method can compute all the zeros.

<br/>
<br/>
<b><big><a name="test_time" id="test_time">test_time</a></big></b>
<br/>
Is the minimum amount of wall clock time that the test should take.
The number of repeats for the test will be increased until this time
is reached. 
The reported 
<code><i><font color="black"><span style='white-space: nowrap'>time_out</span></font></i></code>
 is the total wall clock time divided by the
number of repeats.

<br/>
<br/>
<b><big><a name="num_threads" id="num_threads">num_threads</a></big></b>
<br/>
This argument has prototype

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;size_t&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_threads</span></font></i><font color="blue"><span style='white-space: nowrap'><br/>
</span></font></code>
It specifies the number of threads that 
are available for this test.
If it is zero, the test is run without multi-threading and 

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;1&#xA0;==&#xA0;CppAD::thread_alloc::num_threads()<br/>
</span></font></code>
when <code><font color="blue">multi_newton_time</font></code> is called.
If it is non-zero, the test is run with multi-threading and

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_threads</span></font></i><font color="blue"><span style='white-space: nowrap'>&#xA0;==&#xA0;CppAD::thread_alloc::num_threads()<br/>
</span></font></code>
when <code><font color="blue">multi_newton_time</font></code> is called.

<br/>
<br/>
<b><big><a name="num_zero" id="num_zero">num_zero</a></big></b>
<br/>
This argument has prototype

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;size_t&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_zero</span></font></i><font color="blue"><span style='white-space: nowrap'><br/>
</span></font></code>
and it must be greater than one.
It specifies the actual number of zeros in the test function

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi>sin</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

. 
To be specific, <code><font color="blue">multi_newton_time</font></code> will attempt to determine
all of the values of 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>x</mi>
</mrow></math>

 for which 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi>sin</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mn>0</mn>
</mrow></math>

 and

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>x</mi>
</mrow></math>

 is in the interval

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;[&#xA0;0&#xA0;,&#xA0;(</span></font><i><font color="black"><span style='white-space: nowrap'>num_zero</span></font></i><font color="blue"><span style='white-space: nowrap'>&#xA0;-&#xA0;1)&#xA0;*&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>pi</span></font></i><font color="blue"><span style='white-space: nowrap'>&#xA0;]<br/>
</span></font></code>
.

<br/>
<br/>
<b><big><a name="num_sub" id="num_sub">num_sub</a></big></b>
<br/>
This argument has prototype

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;size_t&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_sub</span></font></i><font color="blue"><span style='white-space: nowrap'><br/>
</span></font></code>
It specifies the number of sub-intervals to divide the total interval into.
It must be greater than zero and
should probably be greater than two times 
<code><i><font color="black"><span style='white-space: nowrap'>num_zero</span></font></i></code>
.

<br/>
<br/>
<b><big><a name="num_sum" id="num_sum">num_sum</a></big></b>
<br/>
This argument has prototype

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;size_t&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>num_sum</span></font></i><font color="blue"><span style='white-space: nowrap'><br/>
</span></font></code>
and must be greater than zero.
The actual function used by the Newton method is

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<mi mathvariant='italic'>f</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mfrac><mrow><mn>1</mn>
</mrow>
<mrow><mi mathvariant='italic'>n</mi>
</mrow>
</mfrac>
<munderover><mo displaystyle='true' largeop='true'>&#x02211;</mo>
<mrow><mi mathvariant='italic'>i</mi>
<mo stretchy="false">=</mo>
<mn>1</mn>
</mrow>
<mrow><mi mathvariant='italic'>n</mi>
</mrow>
</munderover>
<mi>sin</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

where 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>n</mi>
</mrow></math>

 is equal to 
<code><i><font color="black"><span style='white-space: nowrap'>num_sum</span></font></i></code>
.
Larger values of 
<code><i><font color="black"><span style='white-space: nowrap'>num_sum</span></font></i></code>
 simulate a case where the
evaluation of the function 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>f</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

 takes more time.

<br/>
<br/>
<b><big><a name="use_ad" id="use_ad">use_ad</a></big></b>
<br/>
This argument has prototype

<code><font color="blue"><span style='white-space: nowrap'><br/>
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;bool&#xA0;</span></font><i><font color="black"><span style='white-space: nowrap'>user_ad</span></font></i><font color="blue"><span style='white-space: nowrap'><br/>
</span></font></code>
If 
<code><i><font color="black"><span style='white-space: nowrap'>use_ad</span></font></i></code>
 is <code><font color="blue">true</font></code>,
then derivatives will be computed using CppAD.
Note that this derivative computation includes 
re-taping the function for each
value of 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>x</mi>
</mrow></math>

 (even though re-taping is not necessary).
<code><span style='white-space: nowrap'><br/>
<br/>
</span></code>If 
<code><i><font color="black"><span style='white-space: nowrap'>use_ad</span></font></i></code>
 is <code><font color="blue">false</font></code>, 
derivatives will be computed using a hand coded routine.

<br/>
<br/>
<b><big><a name="Source" id="Source">Source</a></big></b>

<code><font color="blue">
<br/>
<pre style='display:inline'> 
# include &lt;cppad/cppad.hpp&gt;
# include &lt;cppad/time_test.hpp&gt;
# include &lt;cmath&gt;
# include &lt;cstring&gt;
# include &quot;multi_newton.hpp&quot;

namespace { // empty namespace 

	// values correspond to arguments in previous call to multi_newton_time
	size_t num_threads_;// value passed to multi_newton_time 
	size_t num_zero_;   // number of zeros of f(x) in the total interval
	size_t num_sub_;    // number of sub-intervals to split calculation into
	size_t num_sum_;    // larger values make f(x) take longer to calculate

	// value of xout corresponding to most recent call to test_once
	CppAD::vector&lt;double&gt; xout_;

	// either fun_ad or fun_no depending on value of use_ad
	void (*fun_)(double x, double&amp; f, double&amp; df) = 0;

	// A version of the sine function that can be made as slow as we like
	template &lt;class Float&gt;
	Float f_eval(Float x)
	{	Float sum = 0.;
		size_t i;
		for(i = 0; i &lt; num_sum_; i++)
			sum += sin(x);

		return sum / Float(num_sum_);
	}

	// Direct calculation of derivative with same number of floating point
	// operations as for f_eval.
	double df_direct(double x)
	{	double sum = 0.;
		size_t i;
		for(i = 0; i &lt; num_sum_; i++)
			sum += cos(x);

		return sum / double(num_sum_);
	}

	// AD calculation of detivative
	void fun_ad(double x, double&amp; f, double&amp; df)
	{	// use CppAD::vector because it uses fast multi-threaded memory alloc
		using CppAD::vector;
		using CppAD::AD;	
		vector&lt; <a href="ad.xml" target="_top">AD</a>&lt;double&gt; &gt; X(1), Y(1);
		X[0] = x;
		CppAD::<a href="independent.xml" target="_top">Independent</a>(X);
		Y[0] = f_eval(X[0]);
		CppAD::<a href="funconstruct.xml" target="_top">ADFun</a>&lt;double&gt; F(X, Y);
		vector&lt;double&gt; dx(1), dy(1);
		dx[0] = 1.;
		dy    = F.<a href="forward.xml" target="_top">Forward</a>(1, dx);
		f     = Value( Y[0] );
		df    = dy[0];
		return;
	} 

	// evaulate the function and its derivative
	void fun_no(double x, double&amp; f, double&amp; df) 
	{	f  = f_eval(x);
		df = df_direct(x);
		return;
	}


	// Run computation of all the zeros once
	void test_once(void)
	{	if(  num_zero_ == 0 )
		{	std::cerr &lt;&lt; &quot;multi_newton_time: num_zero == 0&quot; &lt;&lt; std::endl;
			exit(1);
		}
		double pi      = 4. * std::atan(1.); 
		double xlow    = 0.;
		double xup     = (num_zero_ - 1) * pi;
		double eps     = 100. * CppAD::epsilon&lt;double&gt;();
		size_t max_itr = 20;
	
		bool ok = multi_newton(
			xout_       ,
			fun_        ,
			num_sub_    ,
			xlow        ,
			xup         ,
			eps         ,
			max_itr     ,
			num_threads_ 
		);
		if( ! ok )
		{	std::cerr &lt;&lt; &quot;multi_newton: error&quot; &lt;&lt; std::endl;
			exit(1);
		}
		return;
	}

	// Repeat computation of all the zeros a specied number of times
	void test_repeat(size_t repeat)
	{	size_t i;
		for(i = 0; i &lt; repeat; i++)
			test_once();
		return;
	}
} // end empty namespace

bool multi_newton_time(
	double&amp; time_out      ,
	double  test_time     ,
	size_t  num_threads   ,
	size_t  num_zero      ,
	size_t  num_sub       , 
	size_t  num_sum       ,
	bool    use_ad
) 
{	bool ok = true;
	using CppAD::vector;
	using CppAD::thread_alloc;

	// Set local namespace environment variables
	num_threads_  = num_threads;
	num_zero_     = num_zero;
	num_sub_      = num_sub;
	num_sum_      = num_sum;
	if( use_ad )
		fun_ = fun_ad;
	else	fun_ = fun_no;

	// expect number of threads to already be set up
	if( num_threads &gt; 0 )
		ok &amp;= num_threads == CppAD::thread_alloc::num_threads();
	else	ok &amp;= 1           == CppAD::thread_alloc::num_threads();

	// run the test case and set time return value
	time_out = CppAD::time_test(test_repeat, test_time);

	// Call test_once for a correctness check
	double eps = 100. * CppAD::epsilon&lt;double&gt;();
	double pi  = 4. * std::atan(1.);
	ok        &amp;= (xout_.size() == num_zero);
	size_t i   = 0;
	for(i = 0; i &lt; num_zero; i++)
		ok &amp;= std::fabs( xout_[i] - pi * i) &lt;= 2 * eps;

	// return correctness check result
	return  ok;
}</pre>
</font></code>


<hr/>Input File: multi_thread/multi_newton_time.cpp

</body>
</html>
